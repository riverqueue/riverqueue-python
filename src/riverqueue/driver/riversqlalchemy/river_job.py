# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.26.0
# source: river_job.sql
import dataclasses
import datetime
from typing import Any, AsyncIterator, Iterator, List, Optional

import sqlalchemy
import sqlalchemy.ext.asyncio

from . import models

JOB_CANCEL = """-- name: job_cancel \\:one
WITH
  locked_job AS (
    SELECT
      id,
      queue,
      state,
      finalized_at
    FROM
      river_job
    WHERE
      river_job.id = :p1
    FOR UPDATE
  ),
  notification AS (
    SELECT
      id,
      pg_notify (
        concat(current_schema(), '.', :p2\\:\\:text),
        json_build_object('action', 'cancel', 'job_id', id, 'queue', queue)\\:\\:text
      )
    FROM
      locked_job
    WHERE
      state NOT IN ('cancelled', 'completed', 'discarded')
      AND finalized_at IS NULL
  ),
  updated_job AS (
    UPDATE river_job
    SET
      state = CASE
        WHEN state = 'running'\\:\\:river_job_state THEN state
        ELSE 'cancelled'\\:\\:river_job_state
      END,
      finalized_at = CASE
        WHEN state = 'running'\\:\\:river_job_state THEN finalized_at
        ELSE now()
      END,
      metadata = jsonb_set(
        metadata,
        '{cancel_attempted_at}'\\:\\:text[],
        :p3\\:\\:jsonb,
        true
      )
    FROM
      notification
    WHERE
      river_job.id = notification.id
    RETURNING
      river_job.id, river_job.args, river_job.attempt, river_job.attempted_at, river_job.attempted_by, river_job.created_at, river_job.errors, river_job.finalized_at, river_job.kind, river_job.max_attempts, river_job.metadata, river_job.priority, river_job.queue, river_job.state, river_job.scheduled_at, river_job.tags
  )
SELECT
  id, args, attempt, attempted_at, attempted_by, created_at, errors, finalized_at, kind, max_attempts, metadata, priority, queue, state, scheduled_at, tags
FROM
  river_job
WHERE
  id = :p1\\:\\:bigint
  AND id NOT IN (
    SELECT
      id
    FROM
      updated_job
  )
UNION
SELECT
  id, args, attempt, attempted_at, attempted_by, created_at, errors, finalized_at, kind, max_attempts, metadata, priority, queue, state, scheduled_at, tags
FROM
  updated_job
"""


JOB_COUNT_BY_STATE = """-- name: job_count_by_state \\:one
SELECT
  count(*)
FROM
  river_job
WHERE
  state = :p1
"""


JOB_DELETE_BEFORE = """-- name: job_delete_before \\:one
WITH
  deleted_jobs AS (
    DELETE FROM river_job
    WHERE
      id IN (
        SELECT
          id
        FROM
          river_job
        WHERE
          (
            state = 'cancelled'
            AND finalized_at < :p1\\:\\:timestamptz
          )
          OR (
            state = 'completed'
            AND finalized_at < :p2\\:\\:timestamptz
          )
          OR (
            state = 'discarded'
            AND finalized_at < :p3\\:\\:timestamptz
          )
        ORDER BY
          id
        LIMIT
          :p4\\:\\:bigint
      )
    RETURNING
      id, args, attempt, attempted_at, attempted_by, created_at, errors, finalized_at, kind, max_attempts, metadata, priority, queue, state, scheduled_at, tags
  )
SELECT
  count(*)
FROM
  deleted_jobs
"""


JOB_GET_AVAILABLE = """-- name: job_get_available \\:many
WITH
  locked_jobs AS (
    SELECT
      id, args, attempt, attempted_at, attempted_by, created_at, errors, finalized_at, kind, max_attempts, metadata, priority, queue, state, scheduled_at, tags
    FROM
      river_job
    WHERE
      state = 'available'\\:\\:river_job_state
      AND queue = :p2\\:\\:text
      AND scheduled_at <= now()
    ORDER BY
      priority ASC,
      scheduled_at ASC,
      id ASC
    LIMIT
      :p3\\:\\:integer
    FOR UPDATE
      SKIP LOCKED
  )
UPDATE river_job
SET
  state = 'running'\\:\\:river_job_state,
  attempt = river_job.attempt + 1,
  attempted_at = now(),
  attempted_by = array_append(river_job.attempted_by, :p1\\:\\:text)
FROM
  locked_jobs
WHERE
  river_job.id = locked_jobs.id
RETURNING
  river_job.id, river_job.args, river_job.attempt, river_job.attempted_at, river_job.attempted_by, river_job.created_at, river_job.errors, river_job.finalized_at, river_job.kind, river_job.max_attempts, river_job.metadata, river_job.priority, river_job.queue, river_job.state, river_job.scheduled_at, river_job.tags
"""


JOB_GET_BY_ID = """-- name: job_get_by_id \\:one
SELECT
  id, args, attempt, attempted_at, attempted_by, created_at, errors, finalized_at, kind, max_attempts, metadata, priority, queue, state, scheduled_at, tags
FROM
  river_job
WHERE
  id = :p1
LIMIT
  1
"""


JOB_GET_BY_ID_MANY = """-- name: job_get_by_id_many \\:many
SELECT
  id, args, attempt, attempted_at, attempted_by, created_at, errors, finalized_at, kind, max_attempts, metadata, priority, queue, state, scheduled_at, tags
FROM
  river_job
WHERE
  id = any (:p1\\:\\:bigint[])
ORDER BY
  id
"""


JOB_GET_BY_KIND_AND_UNIQUE_PROPERTIES = """-- name: job_get_by_kind_and_unique_properties \\:one
SELECT
  id, args, attempt, attempted_at, attempted_by, created_at, errors, finalized_at, kind, max_attempts, metadata, priority, queue, state, scheduled_at, tags
FROM
  river_job
WHERE
  kind = :p1
  AND CASE
    WHEN :p2\\:\\:boolean THEN args = :p3\\:\\:jsonb
    ELSE true
  END
  AND CASE
    WHEN :p4\\:\\:boolean THEN tstzrange (
      :p5\\:\\:timestamptz,
      :p6\\:\\:timestamptz,
      '[)'
    ) @> created_at
    ELSE true
  END
  AND CASE
    WHEN :p7\\:\\:boolean THEN queue = :p8
    ELSE true
  END
  AND CASE
    WHEN :p9\\:\\:boolean THEN state\\:\\:text = any (:p10\\:\\:text[])
    ELSE true
  END
"""


@dataclasses.dataclass()
class JobGetByKindAndUniquePropertiesParams:
    kind: str
    by_args: bool
    args: Any
    by_created_at: bool
    created_at_begin: datetime.datetime
    created_at_end: datetime.datetime
    by_queue: bool
    queue: str
    by_state: bool
    state: List[str]


JOB_GET_BY_KIND_MANY = """-- name: job_get_by_kind_many \\:many
SELECT
  id, args, attempt, attempted_at, attempted_by, created_at, errors, finalized_at, kind, max_attempts, metadata, priority, queue, state, scheduled_at, tags
FROM
  river_job
WHERE
  kind = any (:p1\\:\\:text[])
ORDER BY
  id
"""


JOB_GET_STUCK = """-- name: job_get_stuck \\:many
SELECT
  id, args, attempt, attempted_at, attempted_by, created_at, errors, finalized_at, kind, max_attempts, metadata, priority, queue, state, scheduled_at, tags
FROM
  river_job
WHERE
  state = 'running'\\:\\:river_job_state
  AND attempted_at < :p1\\:\\:timestamptz
ORDER BY
  id
LIMIT
  :p2
"""


JOB_INSERT_FAST = """-- name: job_insert_fast \\:one
INSERT INTO
  river_job (
    args,
    finalized_at,
    kind,
    max_attempts,
    metadata,
    priority,
    queue,
    scheduled_at,
    state,
    tags
  )
VALUES
  (
    :p1\\:\\:jsonb,
    :p2,
    :p3\\:\\:text,
    :p4\\:\\:smallint,
    coalesce(:p5\\:\\:jsonb, '{}'),
    :p6\\:\\:smallint,
    :p7\\:\\:text,
    coalesce(:p8\\:\\:timestamptz, now()),
    :p9\\:\\:river_job_state,
    coalesce(:p10\\:\\:varchar(255) [], '{}')
  )
RETURNING
  id, args, attempt, attempted_at, attempted_by, created_at, errors, finalized_at, kind, max_attempts, metadata, priority, queue, state, scheduled_at, tags
"""


@dataclasses.dataclass()
class JobInsertFastParams:
    args: Any
    finalized_at: Optional[datetime.datetime]
    kind: str
    max_attempts: int
    metadata: Any
    priority: int
    queue: str
    scheduled_at: Optional[datetime.datetime]
    state: models.RiverJobState
    tags: List[str]


JOB_INSERT_FULL = """-- name: job_insert_full \\:one
INSERT INTO
  river_job (
    args,
    attempt,
    attempted_at,
    created_at,
    errors,
    finalized_at,
    kind,
    max_attempts,
    metadata,
    priority,
    queue,
    scheduled_at,
    state,
    tags
  )
VALUES
  (
    :p1\\:\\:jsonb,
    coalesce(:p2\\:\\:smallint, 0),
    :p3,
    coalesce(:p4\\:\\:timestamptz, now()),
    :p5\\:\\:jsonb[],
    :p6,
    :p7\\:\\:text,
    :p8\\:\\:smallint,
    coalesce(:p9\\:\\:jsonb, '{}'),
    :p10\\:\\:smallint,
    :p11\\:\\:text,
    coalesce(:p12\\:\\:timestamptz, now()),
    :p13\\:\\:river_job_state,
    coalesce(:p14\\:\\:varchar(255) [], '{}')
  )
RETURNING
  id, args, attempt, attempted_at, attempted_by, created_at, errors, finalized_at, kind, max_attempts, metadata, priority, queue, state, scheduled_at, tags
"""


@dataclasses.dataclass()
class JobInsertFullParams:
    args: Any
    attempt: int
    attempted_at: Optional[datetime.datetime]
    created_at: Optional[datetime.datetime]
    errors: List[Any]
    finalized_at: Optional[datetime.datetime]
    kind: str
    max_attempts: int
    metadata: Any
    priority: int
    queue: str
    scheduled_at: Optional[datetime.datetime]
    state: models.RiverJobState
    tags: List[str]


JOB_RESCUE_MANY = """-- name: job_rescue_many \\:exec
UPDATE river_job
SET
  errors = array_append(errors, updated_job.error),
  finalized_at = updated_job.finalized_at,
  scheduled_at = updated_job.scheduled_at,
  state = updated_job.state
FROM
  (
    SELECT
      unnest(:p1\\:\\:bigint[]) AS id,
      unnest(:p2\\:\\:jsonb[]) AS error,
      nullif(
        unnest(:p3\\:\\:timestamptz[]),
        '0001-01-01 00\\:00\\:00 +0000'
      ) AS finalized_at,
      unnest(:p4\\:\\:timestamptz[]) AS scheduled_at,
      unnest(:p5\\:\\:text[])\\:\\:river_job_state AS state
  ) AS updated_job
WHERE
  river_job.id = updated_job.id
"""


@dataclasses.dataclass()
class JobRescueManyParams:
    id: List[int]
    error: List[Any]
    finalized_at: List[datetime.datetime]
    scheduled_at: List[datetime.datetime]
    state: List[str]


JOB_RETRY = """-- name: job_retry \\:one
WITH
  job_to_update AS (
    SELECT
      id
    FROM
      river_job
    WHERE
      river_job.id = :p1
    FOR UPDATE
  ),
  updated_job AS (
    UPDATE river_job
    SET
      state = 'available'\\:\\:river_job_state,
      scheduled_at = now(),
      max_attempts = CASE
        WHEN attempt = max_attempts THEN max_attempts + 1
        ELSE max_attempts
      END,
      finalized_at = NULL
    FROM
      job_to_update
    WHERE
      river_job.id = job_to_update.id
      AND river_job.state != 'running'\\:\\:river_job_state
      AND NOT (
        river_job.state = 'available'\\:\\:river_job_state
        AND river_job.scheduled_at < now()
      )
    RETURNING
      river_job.id, river_job.args, river_job.attempt, river_job.attempted_at, river_job.attempted_by, river_job.created_at, river_job.errors, river_job.finalized_at, river_job.kind, river_job.max_attempts, river_job.metadata, river_job.priority, river_job.queue, river_job.state, river_job.scheduled_at, river_job.tags
  )
SELECT
  id, args, attempt, attempted_at, attempted_by, created_at, errors, finalized_at, kind, max_attempts, metadata, priority, queue, state, scheduled_at, tags
FROM
  river_job
WHERE
  id = :p1\\:\\:bigint
  AND id NOT IN (
    SELECT
      id
    FROM
      updated_job
  )
UNION
SELECT
  id, args, attempt, attempted_at, attempted_by, created_at, errors, finalized_at, kind, max_attempts, metadata, priority, queue, state, scheduled_at, tags
FROM
  updated_job
"""


JOB_SCHEDULE = """-- name: job_schedule \\:many
WITH
  jobs_to_schedule AS (
    SELECT
      id
    FROM
      river_job
    WHERE
      state IN ('retryable', 'scheduled')
      AND queue IS NOT NULL
      AND priority >= 0
      AND river_job.scheduled_at <= :p1\\:\\:timestamptz
    ORDER BY
      priority,
      scheduled_at,
      id
    LIMIT
      :p2\\:\\:bigint
    FOR UPDATE
  ),
  river_job_scheduled AS (
    UPDATE river_job
    SET
      state = 'available'\\:\\:river_job_state
    FROM
      jobs_to_schedule
    WHERE
      river_job.id = jobs_to_schedule.id
    RETURNING
      river_job.id
  )
SELECT
  id, args, attempt, attempted_at, attempted_by, created_at, errors, finalized_at, kind, max_attempts, metadata, priority, queue, state, scheduled_at, tags
FROM
  river_job
WHERE
  id IN (
    SELECT
      id
    FROM
      river_job_scheduled
  )
"""


JOB_SET_COMPLETE_IF_RUNNING_MANY = """-- name: job_set_complete_if_running_many \\:many
WITH
  job_to_finalized_at AS (
    SELECT
      unnest(:p1\\:\\:bigint[]) AS id,
      unnest(:p2\\:\\:timestamptz[]) AS finalized_at
  ),
  job_to_update AS (
    SELECT
      river_job.id,
      job_to_finalized_at.finalized_at
    FROM
      river_job,
      job_to_finalized_at
    WHERE
      river_job.id = job_to_finalized_at.id
      AND river_job.state = 'running'\\:\\:river_job_state
    FOR UPDATE
  ),
  updated_job AS (
    UPDATE river_job
    SET
      finalized_at = job_to_update.finalized_at,
      state = 'completed'
    FROM
      job_to_update
    WHERE
      river_job.id = job_to_update.id
    RETURNING
      river_job.id, river_job.args, river_job.attempt, river_job.attempted_at, river_job.attempted_by, river_job.created_at, river_job.errors, river_job.finalized_at, river_job.kind, river_job.max_attempts, river_job.metadata, river_job.priority, river_job.queue, river_job.state, river_job.scheduled_at, river_job.tags
  )
SELECT
  id, args, attempt, attempted_at, attempted_by, created_at, errors, finalized_at, kind, max_attempts, metadata, priority, queue, state, scheduled_at, tags
FROM
  river_job
WHERE
  id IN (
    SELECT
      id
    FROM
      job_to_finalized_at
    EXCEPT
    SELECT
      id
    FROM
      updated_job
  )
UNION
SELECT
  id, args, attempt, attempted_at, attempted_by, created_at, errors, finalized_at, kind, max_attempts, metadata, priority, queue, state, scheduled_at, tags
FROM
  updated_job
"""


JOB_SET_STATE_IF_RUNNING = """-- name: job_set_state_if_running \\:one
WITH
  job_to_update AS (
    SELECT
      id,
      :p1\\:\\:river_job_state IN (
        'retryable'\\:\\:river_job_state,
        'scheduled'\\:\\:river_job_state
      )
      AND metadata ? 'cancel_attempted_at' AS should_cancel
    FROM
      river_job
    WHERE
      id = :p2\\:\\:bigint
    FOR UPDATE
  ),
  updated_job AS (
    UPDATE river_job
    SET
      state = CASE
        WHEN should_cancel THEN 'cancelled'\\:\\:river_job_state
        ELSE :p1\\:\\:river_job_state
      END,
      finalized_at = CASE
        WHEN should_cancel THEN now()
        WHEN :p3\\:\\:boolean THEN :p4
        ELSE finalized_at
      END,
      errors = CASE
        WHEN :p5\\:\\:boolean THEN array_append(errors, :p6\\:\\:jsonb)
        ELSE errors
      END,
      max_attempts = CASE
        WHEN NOT should_cancel
        AND :p7\\:\\:boolean THEN :p8
        ELSE max_attempts
      END,
      scheduled_at = CASE
        WHEN NOT should_cancel
        AND :p9\\:\\:boolean THEN :p10\\:\\:timestamptz
        ELSE scheduled_at
      END
    FROM
      job_to_update
    WHERE
      river_job.id = job_to_update.id
      AND river_job.state = 'running'\\:\\:river_job_state
    RETURNING
      river_job.id, river_job.args, river_job.attempt, river_job.attempted_at, river_job.attempted_by, river_job.created_at, river_job.errors, river_job.finalized_at, river_job.kind, river_job.max_attempts, river_job.metadata, river_job.priority, river_job.queue, river_job.state, river_job.scheduled_at, river_job.tags
  )
SELECT
  id, args, attempt, attempted_at, attempted_by, created_at, errors, finalized_at, kind, max_attempts, metadata, priority, queue, state, scheduled_at, tags
FROM
  river_job
WHERE
  id = :p2\\:\\:bigint
  AND id NOT IN (
    SELECT
      id
    FROM
      updated_job
  )
UNION
SELECT
  id, args, attempt, attempted_at, attempted_by, created_at, errors, finalized_at, kind, max_attempts, metadata, priority, queue, state, scheduled_at, tags
FROM
  updated_job
"""


@dataclasses.dataclass()
class JobSetStateIfRunningParams:
    state: models.RiverJobState
    id: int
    finalized_at_do_update: bool
    finalized_at: Optional[datetime.datetime]
    error_do_update: bool
    error: Any
    max_attempts_update: bool
    max_attempts: int
    scheduled_at_do_update: bool
    scheduled_at: Optional[datetime.datetime]


JOB_UPDATE = """-- name: job_update \\:one
UPDATE river_job
SET
  attempt = CASE
    WHEN :p1\\:\\:boolean THEN :p2
    ELSE attempt
  END,
  attempted_at = CASE
    WHEN :p3\\:\\:boolean THEN :p4
    ELSE attempted_at
  END,
  errors = CASE
    WHEN :p5\\:\\:boolean THEN :p6\\:\\:jsonb[]
    ELSE errors
  END,
  finalized_at = CASE
    WHEN :p7\\:\\:boolean THEN :p8
    ELSE finalized_at
  END,
  state = CASE
    WHEN :p9\\:\\:boolean THEN :p10
    ELSE state
  END
WHERE
  id = :p11
RETURNING
  id, args, attempt, attempted_at, attempted_by, created_at, errors, finalized_at, kind, max_attempts, metadata, priority, queue, state, scheduled_at, tags
"""


@dataclasses.dataclass()
class JobUpdateParams:
    attempt_do_update: bool
    attempt: int
    attempted_at_do_update: bool
    attempted_at: Optional[datetime.datetime]
    errors_do_update: bool
    errors: List[Any]
    finalized_at_do_update: bool
    finalized_at: Optional[datetime.datetime]
    state_do_update: bool
    state: models.RiverJobState
    id: int


class Querier:
    def __init__(self, conn: sqlalchemy.engine.Connection):
        self._conn = conn

    def job_cancel(
        self, *, id: int, control_topic: str, cancel_attempted_at: Any
    ) -> Optional[models.RiverJob]:
        row = self._conn.execute(
            sqlalchemy.text(JOB_CANCEL),
            {"p1": id, "p2": control_topic, "p3": cancel_attempted_at},
        ).first()
        if row is None:
            return None
        return models.RiverJob(
            id=row[0],
            args=row[1],
            attempt=row[2],
            attempted_at=row[3],
            attempted_by=row[4],
            created_at=row[5],
            errors=row[6],
            finalized_at=row[7],
            kind=row[8],
            max_attempts=row[9],
            metadata=row[10],
            priority=row[11],
            queue=row[12],
            state=row[13],
            scheduled_at=row[14],
            tags=row[15],
        )

    def job_count_by_state(self, *, state: models.RiverJobState) -> Optional[int]:
        row = self._conn.execute(
            sqlalchemy.text(JOB_COUNT_BY_STATE), {"p1": state}
        ).first()
        if row is None:
            return None
        return row[0]

    def job_delete_before(
        self,
        *,
        cancelled_finalized_at_horizon: datetime.datetime,
        completed_finalized_at_horizon: datetime.datetime,
        discarded_finalized_at_horizon: datetime.datetime,
        max: int,
    ) -> Optional[int]:
        row = self._conn.execute(
            sqlalchemy.text(JOB_DELETE_BEFORE),
            {
                "p1": cancelled_finalized_at_horizon,
                "p2": completed_finalized_at_horizon,
                "p3": discarded_finalized_at_horizon,
                "p4": max,
            },
        ).first()
        if row is None:
            return None
        return row[0]

    def job_get_available(
        self, *, attempted_by: str, queue: str, max: int
    ) -> Iterator[models.RiverJob]:
        result = self._conn.execute(
            sqlalchemy.text(JOB_GET_AVAILABLE),
            {"p1": attempted_by, "p2": queue, "p3": max},
        )
        for row in result:
            yield models.RiverJob(
                id=row[0],
                args=row[1],
                attempt=row[2],
                attempted_at=row[3],
                attempted_by=row[4],
                created_at=row[5],
                errors=row[6],
                finalized_at=row[7],
                kind=row[8],
                max_attempts=row[9],
                metadata=row[10],
                priority=row[11],
                queue=row[12],
                state=row[13],
                scheduled_at=row[14],
                tags=row[15],
            )

    def job_get_by_id(self, *, id: int) -> Optional[models.RiverJob]:
        row = self._conn.execute(sqlalchemy.text(JOB_GET_BY_ID), {"p1": id}).first()
        if row is None:
            return None
        return models.RiverJob(
            id=row[0],
            args=row[1],
            attempt=row[2],
            attempted_at=row[3],
            attempted_by=row[4],
            created_at=row[5],
            errors=row[6],
            finalized_at=row[7],
            kind=row[8],
            max_attempts=row[9],
            metadata=row[10],
            priority=row[11],
            queue=row[12],
            state=row[13],
            scheduled_at=row[14],
            tags=row[15],
        )

    def job_get_by_id_many(self, *, id: List[int]) -> Iterator[models.RiverJob]:
        result = self._conn.execute(sqlalchemy.text(JOB_GET_BY_ID_MANY), {"p1": id})
        for row in result:
            yield models.RiverJob(
                id=row[0],
                args=row[1],
                attempt=row[2],
                attempted_at=row[3],
                attempted_by=row[4],
                created_at=row[5],
                errors=row[6],
                finalized_at=row[7],
                kind=row[8],
                max_attempts=row[9],
                metadata=row[10],
                priority=row[11],
                queue=row[12],
                state=row[13],
                scheduled_at=row[14],
                tags=row[15],
            )

    def job_get_by_kind_and_unique_properties(
        self, arg: JobGetByKindAndUniquePropertiesParams
    ) -> Optional[models.RiverJob]:
        row = self._conn.execute(
            sqlalchemy.text(JOB_GET_BY_KIND_AND_UNIQUE_PROPERTIES),
            {
                "p1": arg.kind,
                "p2": arg.by_args,
                "p3": arg.args,
                "p4": arg.by_created_at,
                "p5": arg.created_at_begin,
                "p6": arg.created_at_end,
                "p7": arg.by_queue,
                "p8": arg.queue,
                "p9": arg.by_state,
                "p10": arg.state,
            },
        ).first()
        if row is None:
            return None
        return models.RiverJob(
            id=row[0],
            args=row[1],
            attempt=row[2],
            attempted_at=row[3],
            attempted_by=row[4],
            created_at=row[5],
            errors=row[6],
            finalized_at=row[7],
            kind=row[8],
            max_attempts=row[9],
            metadata=row[10],
            priority=row[11],
            queue=row[12],
            state=row[13],
            scheduled_at=row[14],
            tags=row[15],
        )

    def job_get_by_kind_many(self, *, kind: List[str]) -> Iterator[models.RiverJob]:
        result = self._conn.execute(sqlalchemy.text(JOB_GET_BY_KIND_MANY), {"p1": kind})
        for row in result:
            yield models.RiverJob(
                id=row[0],
                args=row[1],
                attempt=row[2],
                attempted_at=row[3],
                attempted_by=row[4],
                created_at=row[5],
                errors=row[6],
                finalized_at=row[7],
                kind=row[8],
                max_attempts=row[9],
                metadata=row[10],
                priority=row[11],
                queue=row[12],
                state=row[13],
                scheduled_at=row[14],
                tags=row[15],
            )

    def job_get_stuck(
        self, *, stuck_horizon: datetime.datetime, max: int
    ) -> Iterator[models.RiverJob]:
        result = self._conn.execute(
            sqlalchemy.text(JOB_GET_STUCK), {"p1": stuck_horizon, "p2": max}
        )
        for row in result:
            yield models.RiverJob(
                id=row[0],
                args=row[1],
                attempt=row[2],
                attempted_at=row[3],
                attempted_by=row[4],
                created_at=row[5],
                errors=row[6],
                finalized_at=row[7],
                kind=row[8],
                max_attempts=row[9],
                metadata=row[10],
                priority=row[11],
                queue=row[12],
                state=row[13],
                scheduled_at=row[14],
                tags=row[15],
            )

    def job_insert_fast(self, arg: JobInsertFastParams) -> Optional[models.RiverJob]:
        row = self._conn.execute(
            sqlalchemy.text(JOB_INSERT_FAST),
            {
                "p1": arg.args,
                "p2": arg.finalized_at,
                "p3": arg.kind,
                "p4": arg.max_attempts,
                "p5": arg.metadata,
                "p6": arg.priority,
                "p7": arg.queue,
                "p8": arg.scheduled_at,
                "p9": arg.state,
                "p10": arg.tags,
            },
        ).first()
        if row is None:
            return None
        return models.RiverJob(
            id=row[0],
            args=row[1],
            attempt=row[2],
            attempted_at=row[3],
            attempted_by=row[4],
            created_at=row[5],
            errors=row[6],
            finalized_at=row[7],
            kind=row[8],
            max_attempts=row[9],
            metadata=row[10],
            priority=row[11],
            queue=row[12],
            state=row[13],
            scheduled_at=row[14],
            tags=row[15],
        )

    def job_insert_full(self, arg: JobInsertFullParams) -> Optional[models.RiverJob]:
        row = self._conn.execute(
            sqlalchemy.text(JOB_INSERT_FULL),
            {
                "p1": arg.args,
                "p2": arg.attempt,
                "p3": arg.attempted_at,
                "p4": arg.created_at,
                "p5": arg.errors,
                "p6": arg.finalized_at,
                "p7": arg.kind,
                "p8": arg.max_attempts,
                "p9": arg.metadata,
                "p10": arg.priority,
                "p11": arg.queue,
                "p12": arg.scheduled_at,
                "p13": arg.state,
                "p14": arg.tags,
            },
        ).first()
        if row is None:
            return None
        return models.RiverJob(
            id=row[0],
            args=row[1],
            attempt=row[2],
            attempted_at=row[3],
            attempted_by=row[4],
            created_at=row[5],
            errors=row[6],
            finalized_at=row[7],
            kind=row[8],
            max_attempts=row[9],
            metadata=row[10],
            priority=row[11],
            queue=row[12],
            state=row[13],
            scheduled_at=row[14],
            tags=row[15],
        )

    def job_rescue_many(self, arg: JobRescueManyParams) -> None:
        self._conn.execute(
            sqlalchemy.text(JOB_RESCUE_MANY),
            {
                "p1": arg.id,
                "p2": arg.error,
                "p3": arg.finalized_at,
                "p4": arg.scheduled_at,
                "p5": arg.state,
            },
        )

    def job_retry(self, *, id: int) -> Optional[models.RiverJob]:
        row = self._conn.execute(sqlalchemy.text(JOB_RETRY), {"p1": id}).first()
        if row is None:
            return None
        return models.RiverJob(
            id=row[0],
            args=row[1],
            attempt=row[2],
            attempted_at=row[3],
            attempted_by=row[4],
            created_at=row[5],
            errors=row[6],
            finalized_at=row[7],
            kind=row[8],
            max_attempts=row[9],
            metadata=row[10],
            priority=row[11],
            queue=row[12],
            state=row[13],
            scheduled_at=row[14],
            tags=row[15],
        )

    def job_schedule(
        self, *, now: datetime.datetime, max: int
    ) -> Iterator[models.RiverJob]:
        result = self._conn.execute(
            sqlalchemy.text(JOB_SCHEDULE), {"p1": now, "p2": max}
        )
        for row in result:
            yield models.RiverJob(
                id=row[0],
                args=row[1],
                attempt=row[2],
                attempted_at=row[3],
                attempted_by=row[4],
                created_at=row[5],
                errors=row[6],
                finalized_at=row[7],
                kind=row[8],
                max_attempts=row[9],
                metadata=row[10],
                priority=row[11],
                queue=row[12],
                state=row[13],
                scheduled_at=row[14],
                tags=row[15],
            )

    def job_set_complete_if_running_many(
        self, *, id: List[int], finalized_at: List[datetime.datetime]
    ) -> Iterator[models.RiverJob]:
        result = self._conn.execute(
            sqlalchemy.text(JOB_SET_COMPLETE_IF_RUNNING_MANY),
            {"p1": id, "p2": finalized_at},
        )
        for row in result:
            yield models.RiverJob(
                id=row[0],
                args=row[1],
                attempt=row[2],
                attempted_at=row[3],
                attempted_by=row[4],
                created_at=row[5],
                errors=row[6],
                finalized_at=row[7],
                kind=row[8],
                max_attempts=row[9],
                metadata=row[10],
                priority=row[11],
                queue=row[12],
                state=row[13],
                scheduled_at=row[14],
                tags=row[15],
            )

    def job_set_state_if_running(
        self, arg: JobSetStateIfRunningParams
    ) -> Optional[models.RiverJob]:
        row = self._conn.execute(
            sqlalchemy.text(JOB_SET_STATE_IF_RUNNING),
            {
                "p1": arg.state,
                "p2": arg.id,
                "p3": arg.finalized_at_do_update,
                "p4": arg.finalized_at,
                "p5": arg.error_do_update,
                "p6": arg.error,
                "p7": arg.max_attempts_update,
                "p8": arg.max_attempts,
                "p9": arg.scheduled_at_do_update,
                "p10": arg.scheduled_at,
            },
        ).first()
        if row is None:
            return None
        return models.RiverJob(
            id=row[0],
            args=row[1],
            attempt=row[2],
            attempted_at=row[3],
            attempted_by=row[4],
            created_at=row[5],
            errors=row[6],
            finalized_at=row[7],
            kind=row[8],
            max_attempts=row[9],
            metadata=row[10],
            priority=row[11],
            queue=row[12],
            state=row[13],
            scheduled_at=row[14],
            tags=row[15],
        )

    def job_update(self, arg: JobUpdateParams) -> Optional[models.RiverJob]:
        row = self._conn.execute(
            sqlalchemy.text(JOB_UPDATE),
            {
                "p1": arg.attempt_do_update,
                "p2": arg.attempt,
                "p3": arg.attempted_at_do_update,
                "p4": arg.attempted_at,
                "p5": arg.errors_do_update,
                "p6": arg.errors,
                "p7": arg.finalized_at_do_update,
                "p8": arg.finalized_at,
                "p9": arg.state_do_update,
                "p10": arg.state,
                "p11": arg.id,
            },
        ).first()
        if row is None:
            return None
        return models.RiverJob(
            id=row[0],
            args=row[1],
            attempt=row[2],
            attempted_at=row[3],
            attempted_by=row[4],
            created_at=row[5],
            errors=row[6],
            finalized_at=row[7],
            kind=row[8],
            max_attempts=row[9],
            metadata=row[10],
            priority=row[11],
            queue=row[12],
            state=row[13],
            scheduled_at=row[14],
            tags=row[15],
        )


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def job_cancel(
        self, *, id: int, control_topic: str, cancel_attempted_at: Any
    ) -> Optional[models.RiverJob]:
        row = (
            await self._conn.execute(
                sqlalchemy.text(JOB_CANCEL),
                {"p1": id, "p2": control_topic, "p3": cancel_attempted_at},
            )
        ).first()
        if row is None:
            return None
        return models.RiverJob(
            id=row[0],
            args=row[1],
            attempt=row[2],
            attempted_at=row[3],
            attempted_by=row[4],
            created_at=row[5],
            errors=row[6],
            finalized_at=row[7],
            kind=row[8],
            max_attempts=row[9],
            metadata=row[10],
            priority=row[11],
            queue=row[12],
            state=row[13],
            scheduled_at=row[14],
            tags=row[15],
        )

    async def job_count_by_state(self, *, state: models.RiverJobState) -> Optional[int]:
        row = (
            await self._conn.execute(sqlalchemy.text(JOB_COUNT_BY_STATE), {"p1": state})
        ).first()
        if row is None:
            return None
        return row[0]

    async def job_delete_before(
        self,
        *,
        cancelled_finalized_at_horizon: datetime.datetime,
        completed_finalized_at_horizon: datetime.datetime,
        discarded_finalized_at_horizon: datetime.datetime,
        max: int,
    ) -> Optional[int]:
        row = (
            await self._conn.execute(
                sqlalchemy.text(JOB_DELETE_BEFORE),
                {
                    "p1": cancelled_finalized_at_horizon,
                    "p2": completed_finalized_at_horizon,
                    "p3": discarded_finalized_at_horizon,
                    "p4": max,
                },
            )
        ).first()
        if row is None:
            return None
        return row[0]

    async def job_get_available(
        self, *, attempted_by: str, queue: str, max: int
    ) -> AsyncIterator[models.RiverJob]:
        result = await self._conn.stream(
            sqlalchemy.text(JOB_GET_AVAILABLE),
            {"p1": attempted_by, "p2": queue, "p3": max},
        )
        async for row in result:
            yield models.RiverJob(
                id=row[0],
                args=row[1],
                attempt=row[2],
                attempted_at=row[3],
                attempted_by=row[4],
                created_at=row[5],
                errors=row[6],
                finalized_at=row[7],
                kind=row[8],
                max_attempts=row[9],
                metadata=row[10],
                priority=row[11],
                queue=row[12],
                state=row[13],
                scheduled_at=row[14],
                tags=row[15],
            )

    async def job_get_by_id(self, *, id: int) -> Optional[models.RiverJob]:
        row = (
            await self._conn.execute(sqlalchemy.text(JOB_GET_BY_ID), {"p1": id})
        ).first()
        if row is None:
            return None
        return models.RiverJob(
            id=row[0],
            args=row[1],
            attempt=row[2],
            attempted_at=row[3],
            attempted_by=row[4],
            created_at=row[5],
            errors=row[6],
            finalized_at=row[7],
            kind=row[8],
            max_attempts=row[9],
            metadata=row[10],
            priority=row[11],
            queue=row[12],
            state=row[13],
            scheduled_at=row[14],
            tags=row[15],
        )

    async def job_get_by_id_many(
        self, *, id: List[int]
    ) -> AsyncIterator[models.RiverJob]:
        result = await self._conn.stream(
            sqlalchemy.text(JOB_GET_BY_ID_MANY), {"p1": id}
        )
        async for row in result:
            yield models.RiverJob(
                id=row[0],
                args=row[1],
                attempt=row[2],
                attempted_at=row[3],
                attempted_by=row[4],
                created_at=row[5],
                errors=row[6],
                finalized_at=row[7],
                kind=row[8],
                max_attempts=row[9],
                metadata=row[10],
                priority=row[11],
                queue=row[12],
                state=row[13],
                scheduled_at=row[14],
                tags=row[15],
            )

    async def job_get_by_kind_and_unique_properties(
        self, arg: JobGetByKindAndUniquePropertiesParams
    ) -> Optional[models.RiverJob]:
        row = (
            await self._conn.execute(
                sqlalchemy.text(JOB_GET_BY_KIND_AND_UNIQUE_PROPERTIES),
                {
                    "p1": arg.kind,
                    "p2": arg.by_args,
                    "p3": arg.args,
                    "p4": arg.by_created_at,
                    "p5": arg.created_at_begin,
                    "p6": arg.created_at_end,
                    "p7": arg.by_queue,
                    "p8": arg.queue,
                    "p9": arg.by_state,
                    "p10": arg.state,
                },
            )
        ).first()
        if row is None:
            return None
        return models.RiverJob(
            id=row[0],
            args=row[1],
            attempt=row[2],
            attempted_at=row[3],
            attempted_by=row[4],
            created_at=row[5],
            errors=row[6],
            finalized_at=row[7],
            kind=row[8],
            max_attempts=row[9],
            metadata=row[10],
            priority=row[11],
            queue=row[12],
            state=row[13],
            scheduled_at=row[14],
            tags=row[15],
        )

    async def job_get_by_kind_many(
        self, *, kind: List[str]
    ) -> AsyncIterator[models.RiverJob]:
        result = await self._conn.stream(
            sqlalchemy.text(JOB_GET_BY_KIND_MANY), {"p1": kind}
        )
        async for row in result:
            yield models.RiverJob(
                id=row[0],
                args=row[1],
                attempt=row[2],
                attempted_at=row[3],
                attempted_by=row[4],
                created_at=row[5],
                errors=row[6],
                finalized_at=row[7],
                kind=row[8],
                max_attempts=row[9],
                metadata=row[10],
                priority=row[11],
                queue=row[12],
                state=row[13],
                scheduled_at=row[14],
                tags=row[15],
            )

    async def job_get_stuck(
        self, *, stuck_horizon: datetime.datetime, max: int
    ) -> AsyncIterator[models.RiverJob]:
        result = await self._conn.stream(
            sqlalchemy.text(JOB_GET_STUCK), {"p1": stuck_horizon, "p2": max}
        )
        async for row in result:
            yield models.RiverJob(
                id=row[0],
                args=row[1],
                attempt=row[2],
                attempted_at=row[3],
                attempted_by=row[4],
                created_at=row[5],
                errors=row[6],
                finalized_at=row[7],
                kind=row[8],
                max_attempts=row[9],
                metadata=row[10],
                priority=row[11],
                queue=row[12],
                state=row[13],
                scheduled_at=row[14],
                tags=row[15],
            )

    async def job_insert_fast(
        self, arg: JobInsertFastParams
    ) -> Optional[models.RiverJob]:
        row = (
            await self._conn.execute(
                sqlalchemy.text(JOB_INSERT_FAST),
                {
                    "p1": arg.args,
                    "p2": arg.finalized_at,
                    "p3": arg.kind,
                    "p4": arg.max_attempts,
                    "p5": arg.metadata,
                    "p6": arg.priority,
                    "p7": arg.queue,
                    "p8": arg.scheduled_at,
                    "p9": arg.state,
                    "p10": arg.tags,
                },
            )
        ).first()
        if row is None:
            return None
        return models.RiverJob(
            id=row[0],
            args=row[1],
            attempt=row[2],
            attempted_at=row[3],
            attempted_by=row[4],
            created_at=row[5],
            errors=row[6],
            finalized_at=row[7],
            kind=row[8],
            max_attempts=row[9],
            metadata=row[10],
            priority=row[11],
            queue=row[12],
            state=row[13],
            scheduled_at=row[14],
            tags=row[15],
        )

    async def job_insert_full(
        self, arg: JobInsertFullParams
    ) -> Optional[models.RiverJob]:
        row = (
            await self._conn.execute(
                sqlalchemy.text(JOB_INSERT_FULL),
                {
                    "p1": arg.args,
                    "p2": arg.attempt,
                    "p3": arg.attempted_at,
                    "p4": arg.created_at,
                    "p5": arg.errors,
                    "p6": arg.finalized_at,
                    "p7": arg.kind,
                    "p8": arg.max_attempts,
                    "p9": arg.metadata,
                    "p10": arg.priority,
                    "p11": arg.queue,
                    "p12": arg.scheduled_at,
                    "p13": arg.state,
                    "p14": arg.tags,
                },
            )
        ).first()
        if row is None:
            return None
        return models.RiverJob(
            id=row[0],
            args=row[1],
            attempt=row[2],
            attempted_at=row[3],
            attempted_by=row[4],
            created_at=row[5],
            errors=row[6],
            finalized_at=row[7],
            kind=row[8],
            max_attempts=row[9],
            metadata=row[10],
            priority=row[11],
            queue=row[12],
            state=row[13],
            scheduled_at=row[14],
            tags=row[15],
        )

    async def job_rescue_many(self, arg: JobRescueManyParams) -> None:
        await self._conn.execute(
            sqlalchemy.text(JOB_RESCUE_MANY),
            {
                "p1": arg.id,
                "p2": arg.error,
                "p3": arg.finalized_at,
                "p4": arg.scheduled_at,
                "p5": arg.state,
            },
        )

    async def job_retry(self, *, id: int) -> Optional[models.RiverJob]:
        row = (await self._conn.execute(sqlalchemy.text(JOB_RETRY), {"p1": id})).first()
        if row is None:
            return None
        return models.RiverJob(
            id=row[0],
            args=row[1],
            attempt=row[2],
            attempted_at=row[3],
            attempted_by=row[4],
            created_at=row[5],
            errors=row[6],
            finalized_at=row[7],
            kind=row[8],
            max_attempts=row[9],
            metadata=row[10],
            priority=row[11],
            queue=row[12],
            state=row[13],
            scheduled_at=row[14],
            tags=row[15],
        )

    async def job_schedule(
        self, *, now: datetime.datetime, max: int
    ) -> AsyncIterator[models.RiverJob]:
        result = await self._conn.stream(
            sqlalchemy.text(JOB_SCHEDULE), {"p1": now, "p2": max}
        )
        async for row in result:
            yield models.RiverJob(
                id=row[0],
                args=row[1],
                attempt=row[2],
                attempted_at=row[3],
                attempted_by=row[4],
                created_at=row[5],
                errors=row[6],
                finalized_at=row[7],
                kind=row[8],
                max_attempts=row[9],
                metadata=row[10],
                priority=row[11],
                queue=row[12],
                state=row[13],
                scheduled_at=row[14],
                tags=row[15],
            )

    async def job_set_complete_if_running_many(
        self, *, id: List[int], finalized_at: List[datetime.datetime]
    ) -> AsyncIterator[models.RiverJob]:
        result = await self._conn.stream(
            sqlalchemy.text(JOB_SET_COMPLETE_IF_RUNNING_MANY),
            {"p1": id, "p2": finalized_at},
        )
        async for row in result:
            yield models.RiverJob(
                id=row[0],
                args=row[1],
                attempt=row[2],
                attempted_at=row[3],
                attempted_by=row[4],
                created_at=row[5],
                errors=row[6],
                finalized_at=row[7],
                kind=row[8],
                max_attempts=row[9],
                metadata=row[10],
                priority=row[11],
                queue=row[12],
                state=row[13],
                scheduled_at=row[14],
                tags=row[15],
            )

    async def job_set_state_if_running(
        self, arg: JobSetStateIfRunningParams
    ) -> Optional[models.RiverJob]:
        row = (
            await self._conn.execute(
                sqlalchemy.text(JOB_SET_STATE_IF_RUNNING),
                {
                    "p1": arg.state,
                    "p2": arg.id,
                    "p3": arg.finalized_at_do_update,
                    "p4": arg.finalized_at,
                    "p5": arg.error_do_update,
                    "p6": arg.error,
                    "p7": arg.max_attempts_update,
                    "p8": arg.max_attempts,
                    "p9": arg.scheduled_at_do_update,
                    "p10": arg.scheduled_at,
                },
            )
        ).first()
        if row is None:
            return None
        return models.RiverJob(
            id=row[0],
            args=row[1],
            attempt=row[2],
            attempted_at=row[3],
            attempted_by=row[4],
            created_at=row[5],
            errors=row[6],
            finalized_at=row[7],
            kind=row[8],
            max_attempts=row[9],
            metadata=row[10],
            priority=row[11],
            queue=row[12],
            state=row[13],
            scheduled_at=row[14],
            tags=row[15],
        )

    async def job_update(self, arg: JobUpdateParams) -> Optional[models.RiverJob]:
        row = (
            await self._conn.execute(
                sqlalchemy.text(JOB_UPDATE),
                {
                    "p1": arg.attempt_do_update,
                    "p2": arg.attempt,
                    "p3": arg.attempted_at_do_update,
                    "p4": arg.attempted_at,
                    "p5": arg.errors_do_update,
                    "p6": arg.errors,
                    "p7": arg.finalized_at_do_update,
                    "p8": arg.finalized_at,
                    "p9": arg.state_do_update,
                    "p10": arg.state,
                    "p11": arg.id,
                },
            )
        ).first()
        if row is None:
            return None
        return models.RiverJob(
            id=row[0],
            args=row[1],
            attempt=row[2],
            attempted_at=row[3],
            attempted_by=row[4],
            created_at=row[5],
            errors=row[6],
            finalized_at=row[7],
            kind=row[8],
            max_attempts=row[9],
            metadata=row[10],
            priority=row[11],
            queue=row[12],
            state=row[13],
            scheduled_at=row[14],
            tags=row[15],
        )
